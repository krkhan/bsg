##! This script analyzes exploit attempts that can be a precursor to botnet infection. 
##! For the time being, we look at the number of failed login attempts (break in) and
##! communication with ip's blacklisted for being involved in exploit activities. 

@load ./break-in
@load botflex/utils/types
@load botflex/services/blacklist_mgr

module Exploit;

export {
	redef enum Log::ID += { LOG };

	type Info: record {
		ts:                	time              &log;
		victim_ip:         	addr              &log;
		ssh_attackers:     	string            &log;
		blacklist_attacker:     string            &log;
		msg:               	string            &log;
		submsg:            	string            &log;
		
	};
	
	redef record connection += {
	conn: Info &optional;
	};
	
	## The contributory factors to major event exploit
	type exploit_tributary: enum { Breakin, Blacklist_exploit_match };

	## Expire interval for the global table concerned with maintaining exploit info
	const wnd_exploit = 15mins;

	## The evaluation mode (one of the modes defined in enum evaluation_mode in utils/types)
	const exploit_evaluation_mode = OR;

	## Event that can be handled to access the exploit
	## record as it is sent on to the logging framework.
	global log_exploit: event(rec: Info);

	## The event that sufficient evidence has been gathered to declare the
	## exploit phase of botnet infection lifecycle
	global exploit: event( ts: time, victim: addr, msg: string, ssh_attackers: set[addr], blacklist_attacker: string );
}

## Type of the value of the global table table_exploit
## Additional contributary factors that increase the confidence
## about major event exploit should be added here. For now, we are
## going with boolean scoring. Later, this may need to be adjusted if 
## we choose to use weights.  
type ExploitRecord: record {
	tb_tributary: table[ exploit_tributary ] of bool;
	ssh_attackers: set[addr];
	blacklist_attacker: string &default="";
	submsg: string &default="";     	
};


event bro_init() &priority=5
	{
	Log::create_stream( Exploit::LOG, [$columns=Info, $ev=log_exploit] );

	if ( "exploit" in Config::table_config  )
			{
			if ( "wnd_exploit" in Config::table_config["exploit"] )
				{
				local str_interval = Config::table_config["exploit"]["wnd_exploit"];
				wnd_exploit = string_to_interval(str_interval);
				}

			if ( "evaluation_mode" in Config::table_config["exploit"] )
				{
				local str_mode = Config::table_config["exploit"]["evaluation_mode"];
				exploit_evaluation_mode = string_to_evaluationmode(str_mode);
				}
			}
	}
global exploit_info:Exploit::Info;

## The following set of functions calculate and, or and majority on a table of
## booleans
function get_and( tb : table[exploit_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( !tb[rec] )
			return F;
		}
	return T;
	}

function get_or( tb : table[exploit_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( tb[rec] )
			return T;
		}
	return F;	
	}

function get_majority( tb : table[exploit_tributary] of bool ): bool
	{
	local t = 0;
	local f = 0;
	for ( rec in tb )
		{
		if ( tb[rec] )
			++t;
		else
			++f;
		}

	if ( f > t )
		return F;
	else
		return T;
	}

## The function that decides whether or not the major event exploit should
## be generated. It is called (i) every time an entry in the global table 
## table_exploit reaches certain age defined by the table attribute &create_expire,
## or (ii) Any of the counters for a source ip exceeds its threshold. 

function evaluate( victim_ip: addr, t: table[addr] of ExploitRecord ): bool
	{
	local do_report: bool;
	if ( exploit_evaluation_mode == OR )
		do_report = get_or(t[victim_ip]$tb_tributary);
	else if ( exploit_evaluation_mode == AND )
		do_report = get_and(t[victim_ip]$tb_tributary);
	else if ( exploit_evaluation_mode == MAJORITY )
		do_report = get_majority(t[victim_ip]$tb_tributary);

		
	if( do_report )
		{
		local msg="";
		if ( t[victim_ip]$tb_tributary[Breakin] )
			msg = msg + fmt("%s tried to break into host: %s;", 
			setaddr_to_string(t[victim_ip]$ssh_attackers,","), t[victim_ip]$submsg );
		if ( t[victim_ip]$tb_tributary[Blacklist_exploit_match] )
			msg = msg + fmt("Host contacted %s, an IP blacklisted for exploit activities;",
					 t[victim_ip]$blacklist_attacker);
		
    		event exploit( network_time(), victim_ip, msg, t[victim_ip]$ssh_attackers, t[victim_ip]$blacklist_attacker );		

		## Log bot_attack related entries
		exploit_info$ts = network_time();
		exploit_info$victim_ip = victim_ip;
		exploit_info$ssh_attackers = setaddr_to_string(t[victim_ip]$ssh_attackers,",");
		exploit_info$msg = msg;
		exploit_info$submsg = t[victim_ip]$submsg;
		exploit_info$blacklist_attacker = t[victim_ip]$blacklist_attacker;

		Log::write(Exploit::LOG,exploit_info);

		return T;
		}
	return F;
	}

## Called when an entry in the global table table_exploit exceeds certain age, as specified
## in the table attribute create_expire.
function exploit_record_expired(t: table[addr] of ExploitRecord, idx: any): interval
	{
	evaluate( idx, t );
	return 0secs;
	}


## The global state table that maintains various information pertaining to the
## major event exploit, and is analyzed when a decision has to be made whether
## or not to declare the major event exploit.
global table_exploit: table[addr] of ExploitRecord &create_expire=wnd_exploit &expire_func=exploit_record_expired;

function get_exploit_record(): ExploitRecord
	{
	local rec: ExploitRecord;
	local s: set[addr];
	rec$ssh_attackers = s;
	#local t: table[ exploit_tributary ] of bool;
	#rec$tb_tributary = t;
	return rec;
	}

event Breakin::breakin( victim_ip: addr, ssh_attackers: set[addr], msg: string )
	{
	if ( victim_ip !in table_exploit )
		table_exploit[victim_ip] = get_exploit_record();

	# Update breakin info
	table_exploit[victim_ip]$tb_tributary[ Breakin ] = T;	
	table_exploit[victim_ip]$ssh_attackers = ssh_attackers;	
	table_exploit[victim_ip]$submsg = msg;

	local done = evaluate( victim_ip, table_exploit );
	if ( done )
		{
		delete table_exploit[victim_ip]$tb_tributary[ Breakin ];
		for ( rec in table_exploit[victim_ip]$ssh_attackers )	
			delete table_exploit[victim_ip]$ssh_attackers[rec];	
		table_exploit[victim_ip]$submsg = "";
		}	
	}

event connection_established( c: connection )
	{
	local our_ip: addr;
	local other_ip: addr;
	local outbound = Site::is_local_addr(c$id$orig_h);

	our_ip = outbound? c$id$orig_h: c$id$resp_h;
	other_ip = outbound? c$id$resp_h: c$id$orig_h;

	## Match found in blacklist
	if ( fmt("%s",other_ip) in BlacklistMgr::tb_blacklists["exploit_ip"] )
		{
		if ( our_ip !in table_exploit )
			table_exploit[our_ip] = get_exploit_record();

		table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ] = T;
		table_exploit[our_ip]$blacklist_attacker = fmt("%s",other_ip);
		local done = evaluate( our_ip, table_exploit );
		if ( done )
			{
			delete table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ];
			table_exploit[our_ip]$blacklist_attacker = "";
			}
		}	
	}
