##! This script analyzes exploit attempts that can be a precursor to botnet infection. 
##! For the time being, we look at the number of failed login attempts (break in) and
##! communication with ip's blacklisted for being involved in exploit activities. 

@load ./break-in
@load botflex/utils/types
@load botflex/services/blacklist_mgr

module Exploit;

export {
	redef enum Log::ID += { LOG };

	type Info: record {
		ts:                		time              &log;
		victim_ip:         		addr              &log;
		ssh_attackers:     		string            &log;
		blacklist_attacker_ip:     	string            &log;
		blacklist_attacker_url:     	string            &log;
		msg:               		string            &log;
		submsg:               		string            &log;
		
	};
	
	redef record connection += {
	conn: Info &optional;
	};
	
	## The contributory factors to major event exploit
	type exploit_tributary: enum { Breakin, Blacklist_exploit_match };

	## Expire interval for the global table concerned with maintaining exploit info
	const wnd_exploit = 15mins &redef;

	## The evaluation mode (one of the modes defined in enum evaluation_mode in utils/types)
	const exploit_evaluation_mode = OR;

	## Event that can be handled to access the exploit
	## record as it is sent on to the logging framework.
	global log_exploit: event(rec: Info);

	## The event that sufficient evidence has been gathered to declare the
	## exploit phase of botnet infection lifecycle
	global exploit: event( ts: time, victim: addr, msg: string, ssh_attackers: set[addr], 
			       blacklist_attacker: string, blacklist_attacker_url: string );
}

## Type of the value of the global table table_exploit
## Additional contributary factors that increase the confidence
## about major event exploit should be added here. For now, we are
## going with boolean scoring. Later, this may need to be adjusted if 
## we choose to use weights.  
type ExploitRecord: record {
	tb_tributary: table[ exploit_tributary ] of bool;
	ssh_attackers: set[addr];
	blacklist_attacker: string &default="";
	blacklist_attacker_url: string &default="";
	submsg: string &default="";
	reported_ip: set[addr];
    	reported_url: set[string];     	
};


event bro_init() &priority=5
	{
	Log::create_stream( Exploit::LOG, [$columns=Info, $ev=log_exploit] );

	if ( "exploit" in Config::table_config  )
			{
			if ( "wnd_exploit" in Config::table_config["exploit"] )
				{
				wnd_exploit = string_to_interval(Config::table_config["exploit"]["wnd_exploit"]);
				}

			if ( "evaluation_mode" in Config::table_config["exploit"] )
				{
				local str_mode = Config::table_config["exploit"]["evaluation_mode"];
				exploit_evaluation_mode = string_to_evaluationmode(str_mode);
				}
			}
	}
global exploit_info:Exploit::Info;

## The following set of functions calculate and, or and majority on a table of
## booleans
function get_and( tb : table[exploit_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( !tb[rec] )
			return F;
		}
	return T;
	}

function get_or( tb : table[exploit_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( tb[rec] )
			return T;
		}
	return F;	
	}

function get_majority( tb : table[exploit_tributary] of bool ): bool
	{
	local t = 0;
	local f = 0;
	for ( rec in tb )
		{
		if ( tb[rec] )
			++t;
		else
			++f;
		}

	if ( f > t )
		return F;
	else
		return T;
	}

## The function that decides whether or not the major event exploit should
## be generated. It is called (i) every time an entry in the global table 
## table_exploit reaches certain age defined by the table attribute &create_expire,
## or (ii) Any of the counters for a source ip exceeds its threshold. 

function evaluate( victim_ip: addr, t: table[addr] of ExploitRecord ): bool
	{
	local do_report: bool;
	if ( exploit_evaluation_mode == OR )
		do_report = get_or(t[victim_ip]$tb_tributary);
	else if ( exploit_evaluation_mode == AND )
		do_report = get_and(t[victim_ip]$tb_tributary);
	else if ( exploit_evaluation_mode == MAJORITY )
		do_report = get_majority(t[victim_ip]$tb_tributary);

		
	if( do_report )
		{
		local msg = "";
		if ( t[victim_ip]$tb_tributary[Breakin] )
			msg = msg + fmt("%s tried to break into: %s;", 
			setaddr_to_string(t[victim_ip]$ssh_attackers,","), t[victim_ip]$submsg );
		if ( t[victim_ip]$tb_tributary[Blacklist_exploit_match] )
			msg = msg + fmt("Host Exploit: %s",t[victim_ip]$submsg);
		
    		event exploit( network_time(), victim_ip, msg, t[victim_ip]$ssh_attackers, 
			       t[victim_ip]$blacklist_attacker, t[victim_ip]$blacklist_attacker_url );		

		## Log bot_attack related entries
		exploit_info$ts = network_time();
		exploit_info$victim_ip = victim_ip;
		exploit_info$ssh_attackers = setaddr_to_string(t[victim_ip]$ssh_attackers,",");
		exploit_info$msg = msg;
		exploit_info$submsg = t[victim_ip]$submsg;
		exploit_info$blacklist_attacker_ip = t[victim_ip]$blacklist_attacker;
		exploit_info$blacklist_attacker_url = t[victim_ip]$blacklist_attacker_url;

		Log::write(Exploit::LOG,exploit_info);

		return T;
		}
	return F;
	}

## Called when an entry in the global table table_exploit exceeds certain age, as specified
## in the table attribute create_expire.
function exploit_record_expired(t: table[addr] of ExploitRecord, idx: any): interval
	{
	evaluate( idx, t );print "EXPIRED";
	return 0secs;
	}


## The global state table that maintains various information pertaining to the
## major event exploit, and is analyzed when a decision has to be made whether
## or not to declare the major event exploit.
global table_exploit: table[addr] of ExploitRecord &create_expire=Exploit::wnd_exploit &expire_func=exploit_record_expired;

function get_exploit_record(): ExploitRecord
	{
	local rec: ExploitRecord;
	local s1: set[addr];
	rec$ssh_attackers = s1;
	local s2: set[addr];
	rec$reported_ip = s2;
	local s3: set[string];
	rec$reported_url = s3;	
	#local t: table[ exploit_tributary ] of bool;
	#rec$tb_tributary = t;
	return rec;
	}

event Breakin::breakin( victim_ip: addr, ssh_attackers: set[addr], msg: string )
	{
	if ( victim_ip !in table_exploit )
		table_exploit[victim_ip] = get_exploit_record();

	# Update breakin info
	table_exploit[victim_ip]$tb_tributary[ Breakin ] = T;	
	table_exploit[victim_ip]$ssh_attackers = ssh_attackers;	
	table_exploit[victim_ip]$submsg = table_exploit[victim_ip]$submsg + msg + ";";

	local done = evaluate( victim_ip, table_exploit );
	if ( done )
		{
		delete table_exploit[victim_ip]$tb_tributary[ Breakin ];
		for ( rec in table_exploit[victim_ip]$ssh_attackers )	
			delete table_exploit[victim_ip]$ssh_attackers[rec];	
		table_exploit[victim_ip]$submsg = "";
		}	
	}

event connection_established( c: connection )
	{
	local our_ip: addr;
	local other_ip: addr;
	local matched = F;
	local outbound = Site::is_local_addr(c$id$orig_h);

	our_ip = outbound? c$id$orig_h: c$id$resp_h;
	other_ip = outbound? c$id$resp_h: c$id$orig_h;

	
	## Match found in blacklist
	if ( fmt("%s",other_ip) in BlacklistMgr::tb_blacklists["exploit_ip"] )
		{
		if ( our_ip !in table_exploit )
			table_exploit[our_ip] = get_exploit_record();

		if ( other_ip !in table_exploit[our_ip]$reported_ip )
			{
			table_exploit[our_ip]$submsg = "Exploit IP blacklist matched;";
			table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ] = T;
			table_exploit[our_ip]$blacklist_attacker = fmt("%s",other_ip);
			matched = T;
			}
		for ( snet in BlacklistMgr::blacklist_bogon_subnet )
			{
			if ( other_ip in snet )
				{
				if ( our_ip !in table_exploit )
					table_exploit[our_ip] = get_exploit_record();

				table_exploit[our_ip]$submsg = "Bogon blacklist matched;";
				table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ] = T;
				table_exploit[our_ip]$blacklist_attacker = fmt("%s",other_ip);
				matched = T;
				}
			}

		local done = F;
		if ( matched )
			done = evaluate( our_ip, table_exploit );
		if ( done )
			{
			add table_exploit[our_ip]$reported_ip[other_ip];
			delete table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ];
			table_exploit[our_ip]$blacklist_attacker = "";
			}
		}	
	}


event http_reply(c: connection, version: string, code: count, reason: string)
	{
	local our_ip: addr;
	local other_ip: addr;
	local matched = F;
	local msg = "";
	local outbound = Site::is_local_addr(c$id$orig_h);

	our_ip = outbound? c$id$orig_h: c$id$resp_h;
	other_ip = outbound? c$id$resp_h: c$id$orig_h;
	
	if ( c$http$host in BlacklistMgr::tb_blacklists["exploit_url"] )
		{
		matched = T;
		msg = "Exploit URL blacklist matched;";
		}
	if ( c$http$host in BlacklistMgr::tb_blacklists["drive_by_download_url"] )
		{
		matched = T;
		msg = "Exploit (Drive-by-download) URL blacklist matched;";
		}
	if ( matched )
		{
		if ( our_ip !in table_exploit )
			{
			table_exploit[our_ip] = get_exploit_record();
			}

		if ( c$http$host !in table_exploit[our_ip]$reported_url )
			{
			table_exploit[our_ip]$submsg = msg;
			table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ] = T;
			table_exploit[our_ip]$blacklist_attacker = fmt("%s",other_ip);
			table_exploit[our_ip]$blacklist_attacker_url = fmt("%s", c$http$host );

			local done = evaluate( our_ip, table_exploit );
			if ( done )
				{
				add table_exploit[our_ip]$reported_url[c$http$host];
				delete table_exploit[our_ip]$tb_tributary[ Blacklist_exploit_match ];
				table_exploit[our_ip]$blacklist_attacker = "";
				table_exploit[our_ip]$blacklist_attacker_url = "";
				}	
			}	
		}			
	}
