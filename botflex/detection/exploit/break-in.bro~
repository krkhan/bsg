##! This script analyzes if remote host(s) are trying to break into
##! the monitored network. 

@load base/protocols/ssh
@load botflex/config
@load botflex/utils/types

module Breakin;

export {
	redef enum Log::ID += { LOG };

	type Info: record {
		ts:                time             &log;
		victim_ip:         addr             &log;
		ssh_attackers:     string           &log;
		msg:               string           &log;
	};
	
	redef record connection += {
	conn: Info &optional;
	};
	
	## The contributory factors to the event breakin
	type breakin_tributary: enum { Ssh_failed_login };

	## The evaluation mode (one of the modes defined in enum evaluation_mode in utils/types)
	const breakin_evaluation_mode = OR &redef;

	## The table that maps breakin_tributary enum values to strings
	global tb_tributary_string: table[ breakin_tributary ] of string; 

	## Event that can be handled to access the breakin
	## record as it is sent on to the logging framework.
	global log_breakin: event(rec: Info);

	## The event that spam.bro reported spam
	global breakin: event( victim_ip: addr, attackers: set[addr], msg: string );

	## Thresholds for different contributors to the major event exploit
	const ssh_login_threshold = 1 &redef;

	## Expire interval for the global table concerned with maintaining break in info
	const wnd_breakin = 15mins;
       }

global breakin_info:Breakin::Info;

event bro_init() &priority=5
	{	
	Log::create_stream(Breakin::LOG, [$columns=Info, $ev=log_breakin]);

	## Map all possible values of enum breakin_tributary to corresponding strings
	## here. This table will be used to formulate a human readable string for sharing 
	## with other scripts.
	tb_tributary_string[ Ssh_failed_login ] = "Failed SSH login attempts";

	if ( "exploit" in Config::table_config  )
			{
			if ( "th_ssh_login" in Config::table_config["exploit"] )
				{
				ssh_login_threshold = to_count(Config::table_config["exploit"]["th_ssh_login"]);
				}

			if ( "wnd_breakin" in Config::table_config["exploit"] )
				{
				local str_interval = Config::table_config["exploit"]["wnd_breakin"];
				wnd_breakin = string_to_interval(str_interval);
				}
			if ( "evaluation_breakin_mode" in Config::table_config["exploit"] )
				{
				local str_mode = Config::table_config["exploit"]["evaluation_breakin_mode"];
				breakin_evaluation_mode = string_to_evaluationmode(str_mode);
				}
			}
	}

## Type of the value of the global table table_breakin
## Additional contributary factors that increase the confidence
## about major event exploit should be added here
type BreakinRecord: record {
    tb_tributary: table[ breakin_tributary ] of bool;
    ssh_logins: count &default=0;
    ssh_attackers: set[addr];  		
};

## The following set of functions calculate and, or and majority on a table of
## booleans
function get_and( tb : table[breakin_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( !tb[rec] )
			return F;
		}
	return T;
	}

function get_or( tb : table[breakin_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( tb[rec] )
			return T;
		}
	return F;	
	}

function get_majority( tb : table[breakin_tributary] of bool ): bool
	{
	local t = 0;
	local f = 0;
	for ( rec in tb )
		{
		if ( tb[rec] )
			++t;
		else
			++f;
		}

	if ( f > t )
		return F;
	else
		return T;
	}


function evaluate_breakin( dst_ip: addr, t: table[addr] of BreakinRecord  ): bool
	{
	local do_report: bool;
	if ( breakin_evaluation_mode == OR )
		do_report = get_or(t[dst_ip]$tb_tributary);
	else if ( breakin_evaluation_mode == AND )
		do_report = get_and(t[dst_ip]$tb_tributary);
	else if ( breakin_evaluation_mode == MAJORITY )
		do_report = get_majority(t[dst_ip]$tb_tributary);
		
	if( do_report )
		{
		## Other contributory factors to the event cnc should
		## be appended to this msg.
		local msg = "";
		for ( rec in t[dst_ip]$tb_tributary )
			msg = msg + tb_tributary_string[rec] + ",";

		event Breakin::breakin( dst_ip, t[dst_ip]$ssh_attackers, msg );

		## Log breakin-related entries
		breakin_info$ts = network_time();
		breakin_info$victim_ip = dst_ip;
		breakin_info$ssh_attackers = setaddr_to_string(t[dst_ip]$ssh_attackers, ",");
		breakin_info$msg = msg;

		Log::write(Breakin::LOG,breakin_info);

		return T;
		}	
	return F;	
	}

## Called when an entry in the global table table_breakin exceeds certain age, as specified
## in the table attribute create_expire.
function breakin_record_expired(t: table[addr] of BreakinRecord, idx: any): interval
	{
	evaluate_breakin(idx, t);
	return 0secs;
	}

# The global state table that maintains various information pertaining to the
## major exploit, and is analyzed when a decision has to be made whether
## or not to declare the major event exploit.
global table_breakin: table[addr] of BreakinRecord &create_expire=wnd_breakin &expire_func=breakin_record_expired;	

function get_breakin_record(): BreakinRecord
	{
	local rec: BreakinRecord;
	local s: set[addr];
	rec$ssh_attackers = s;
	return rec;
	}

## Keep track of the total number of inbound failed ssh logins within a 
## time window, regardless of the source ip. For all we know, the attacker
## might be using spoofed source ip's to force his way into our host.
event SSH::heuristic_failed_login(c: connection)
	{
	local outbound = Site::is_local_addr(c$id$orig_h);

	if ( !outbound )
		{
		local id = c$id;
		local victim = id$resp_h;

		# if this is the first time src_ip appears
		if ( victim !in table_breakin )
			table_breakin[victim] = get_breakin_record();

		++ table_breakin[victim]$ssh_logins;
		add table_breakin[victim]$ssh_attackers[id$orig_h];
	
		if ( table_breakin[victim]$ssh_logins > ssh_login_threshold )
			{
			table_breakin[victim]$tb_tributary[ Ssh_failed_login ] = T;
			local done = evaluate_breakin( victim, table_breakin );
			if ( done )
				{
				delete table_breakin[victim]$tb_tributary[ Ssh_failed_login ];
				table_breakin[victim]$ssh_logins = 0;
				for ( rec in table_breakin[victim]$ssh_attackers )
					delete table_breakin[victim]$ssh_attackers[rec];
				}
			}
		}
	}


